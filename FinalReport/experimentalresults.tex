
Put your Experimental results
\section{Testing Frame Construction(FrameObj)}
%Rebecca
% not sure how much of this le will go over...  :/
An easy way of being able to integrate with the other teams seemed to be through the creation of a class, FrameObj, which would not only provide the other modules with a means of creating a frame but a list of properties that could be called for easy debugging. In this object we can also store the values of constants and the ID numbers of devices, statuses, etc.  There are two ways that an instance of the class FrameObj could be constructed,  from the basic requirements of the frame (Frame type, Sender ID number , Receiver ID number, and Data) or from the bits of a frame.

FrameObj was written with a property for almost every field in the frame format. One notable exception is the data field of the frame. The property data is actually a combination of the data field and the CRC for the data. There are some additional properties as well; header and frameArray are not individual fields, instead they combine the fields of the entire header and frame respectively. The property classUse is not intended to be used outside the of the property data, it signifies which of the two ways of class initialization are used so that the data field can operate differently for either as well as for the different frameTypes.
 
\begin{lstlisting} 
    properties
        classUse    %Identifies which configuration was used in this instance of FrameObj
        frameType   %Identifies the type of frame that is being used
        rcvID       %The identification number of the destination receiver
        sndID       %The identification number of the sender.
        data        %The data field (cuts off after more than 234 bytes)
        
    end
    properties (Dependent)
        dataSize    %Indicates the length of the payload in bytes.
        header      %The array of the frame header with hCRC8
        hCRC8       %CRC-8 code verfication of the header field
        dCRC8       %CRC-8 code verfication of the data field
        frameArray  %The frame as an n*1 array
    end
\end{lstlisting}

While writing FrameObj we also wrote the script FrameTest to test the various configurations under which FrameObj might be used. We tried to account for errors, both through using CRCs to protect our bits and by preparing for the rare errors that could happen and not result in an error with the CRC. FrameTest has been re-ordered in sections to best explain the current configuration of FrameObj and not to reflect the code development of FrameObj.

The first section of FrameTest shows the creation of an ACK frame. An ACK is a frame header with the frametype ACKFRAME. In FrameTest it is created from the frame constants: ACKFRAME, UEID1, and UEID2 with a zero entered instead of data.   

\begin{lstlisting}
%% FrameTest.m Section 1: ACK
disp('Section 1: Test ACKFRAME frameType') 
% create ACK
ACKtype = FrameObj(FrameObj.ACKFRAME, FrameObj.IDUE1, FrameObj.IDUE2, 0);
\end{lstlisting}

These constant properties correspond to the numbers 255, 101, and 102. Instead of just passing frameType=255 through the FrameObj (as we do with device ID numbers) we use a switch statement to compare the frameType input field to the six frameTypes used in FrameObj. The frameType is the most important property of our frame, it is the first part checked every time a frame is received. If a number is used that is not associated with a frameType it will result in a frame that is INVALID.

\begin{lstlisting} 
%frameType
        function obj = set.frameType(obj,inputframeType)
            %Using the switch statement in this way ensures that a
            %supported data type is used
            switch inputframeType
                case FrameObj.DATAFRAME     %DATA
                    obj.frameType = uint8(inputframeType);
                case FrameObj.ACKFRAME      %ACK
                    obj.frameType = uint8(inputframeType);
                case FrameObj.POLLFRAME     %POLL
                    obj.frameType = uint8(inputframeType);
                case FrameObj.REQFRAME      %REQ
                    obj.frameType = uint8(inputframeType);
                case FrameObj.TABLEFRAME    %TABLE
                    obj.frameType = uint8(inputframeType);
                case FrameObj.INVALID       %INVALID
                    obj.frameType = uint8(inputframeType);
                otherwise             % also INVALID
                    obj.frameType = uint8(FrameObj.INVALID);
            end
        end
\end{lstlisting}

Many of the other FrameObj properties depend on frameType. For instance ACK has no data CRC, as it has no data. For an FrameObj with frameType ACKFRAME, calling the property dCRC8 would result in an error, halting the program. Similarly, calling dCRC8 will result in an error if an unspecified frameType is used. This aids with frame creation. When an undefined frameType is used, errors will be triggered for each property that depends on frameType until that functionality is added. This way we can be sure that we are not using functionality assumed from other frameTypes. 

\begin{lstlisting} 
%dCRC8
        %frameType dependent
        function value = get.dCRC8(obj)
            switch obj.frameType
                case FrameObj.DATAFRAME     %DATA
                    %The last byte of obj.data is the CRC. It is seperated
                    %from the data here
                    value = obj.data(end-8:end,1);
                case FrameObj.ACKFRAME      %ACK
                    error('This is an ACK, it has no data therefor no CRC')
                    %If there is no data there should be no check
										....
								otherwise
                    error('Not a supported frame type for dCRC8')
                    % If this error occurs while using a legitimate frame
                    % type please add an addiional case statement for that
                    % frame type.
\end{lstlisting}

No matter what type of valid frame is defined in FrameObj it will always have the same header format and length. The display messages in the command window shown in \ref{fig:FrameTest1} confirm that there are 5 bytes of information in this ACK frame and the dataSize is hard-coded to 0. 

The INVALID frameType is an important part of protecting the class FrameObj from error filled data especially when creating a FrameObj from transceived bits. Critical errors which will cause Matlab errors should result in an INVALID frame. In Section 2 of FrameTest we created three errors that resulted in INVALID frames, the output of this section is shown in \ref{fig:FrameTest2}.

\begin{lstlisting} 
%% FrameTest.m Section 2:INVALID
disp([10 'Section 2: Test INVALID frameType'])
% nonsense frameType
INVALIDtype = FrameObj(20 , FrameObj.IDUE1, FrameObj.IDUE2, 0);

% cut off the number of bits
receivedshort = ACKtype.frameArray(1:39);
shorttype = FrameObj(receivedshort);

% adds 2000 zeros to the end of the bits 'correct'
% change the sender to IDUE3 to cause the CRC to have an error
receivedcbits = [ACKtype.frameArray; zeros(2000, 1)];
receivedcbits(2*8+1:3*8) =de2bi(uint8(FrameObj.IDUE3),8,'left-msb');
wrongcrc = FrameObj(receivedcbits);
\end{lstlisting} 

The first error, INVALIDtype, is the most straight forward, instead of using a legitimate frametype as the first input to FrameObj, we used an invalid number: 20. This input will be passed to frameType where it will not match any of the defined switch cases in the property frameType shown above and will be set to INVALID through 'otherwise'. The output is shown in \ref{fig:FrameTest2}.  This is the only way to create an INVALID frame by using 4 input fields of FrameObj. 

The next two types of errors that result in INVALID frames are checked for in the FrameObj constructor when the input is in bits. The first of these errors stems from the minimum size of a frame and therefore from the minimum acceptable length of the n*1 input. The array used in FrameObj, receivedshort,  must be at least 40 bits long to represent a valid frame. By defaulting all shorter inputs to INVALID we can be certain that we will not be indexing outside of the dimensions of the input. \ref{fig:FrameTest2} shows that when the input has a length of only 39 bits the resulting frameType will be INVALID. 

\begin{lstlisting} 
%onstructor, FrameObj with 1 array of bits
            elseif nargin == 1
                bitwise = inputType;
                 
                %size check
                [size_in, ~] = size(bitwise);
                if (size_in >= 40)
                    % hCRC check
                    hDetect = comm.CRCDetector([8 7 6 4 2 0]);
                    % detects if there is an error in the CRC of the header
                    [~, err] = step(hDetect, bitwise(1:5*8,1));
                    if (err ==0)
																						.....
                    else
                        % the crc does not match and the header is junk
                        obj.frameType = FrameObj.INVALID;
                    end
                else
                    % the data we recdived is not long enough to check the
                    % header crc
                    obj.frameType = FrameObj.INVALID ;     
                end
            else %incorrect number of inputs
                error('That is not a valid number of inputs')
            end
\end{lstlisting} 

The code from the FrameObj constructor above shows the source of the last error that will result in an INVALID frame. After checking for the minimum size of the input, the constructor will check the CRC of the header. In FrameTest we guarantee that the header will cause a CRC error by replacing one UEID number with another in the bit array. An error with the header CRC is not critical for the FrameObj construction but it is important for the functionality of the frame format in the network.

The data field of the frame format is the most complicated property to implement in FrameObj. Not only does it change dramatically with frameType but the way it functions changes with the way that FrameObj is used, with either 1 or 4 inputs. For an ACKFRAME frameType the data property must be initialized as a value or there will be an error but data should not be used. For a DATAFRAME frameType, data must either take in a string or an array of bits. Other frameTypes will have different requirements which means that very little processing can be done in the constructor of the FrameObj, the bulk of data must be defined in the property function. 

Section 3 of TestFrame tests whether the same values for each of the FrameObj properties will be returned. 





\begin{figure}[p]
    \includegraphics[width=0.5\textwidth, left]{FrameTest1.PNG}
    \caption{Command window output of FrameTest Section 1 showing ACK frame attributes }
    \label{fig:FrameTest1}
\end{figure}

\begin{figure}[p]
    \includegraphics[width=0.55\textwidth, left]{FrameTest2.PNG}
    \caption{Command window output of FrameTest Section 2 showing that all three very wrong frames are INVALID }
    \label{fig:FrameTest2}
\end{figure}

\begin{figure}[p]
    \includegraphics[width=0.77\textwidth, left]{FrameTest3.PNG}
    \caption{Command window output of FrameTest Section 3 showing an instances of FrameObj being created from both types of inputs }
    \label{fig:FrameTest3}
\end{figure}

\begin{figure}[p]
    \includegraphics[width=0.77\textwidth, left]{FrameTest4.PNG}
    \caption{Command window output of FrameTest Section 4 showing dataSize limits  }
    \label{fig:FrameTest4}
\end{figure}

\section{Transmitting and receiving over the air}
%Renato
\subsection{Using lab2 physical layer}
\begin{table}
	\centering
		\begin{tabular}{| c | c | }
		\hline                       
		Frame Type UE & Number Received\\
		\hline
			ACK & 2\\
			DATA & 102\\
			corrupt DATA & 2\\
			INVALID & 3466\\
			other & 0\\
		\hline
		\end{tabular}
	\caption{Table of frames received with poor transmission quality and a small hamming distance between frame types}
	\label{tab:2ACK}
\end{table}

\begin{table}
	\centering
		\begin{tabular}{| c | c | }
		\hline                       
		Frame Type & Number Received\\
		\hline
			ACK & 0\\
			DATA & 165\\
			corrupt DATA & 4\\
			INVALID & 3559\\
			other & 0\\
		\hline
		\end{tabular}
	\caption{Table of frames received with poor transmission quality and a larger hamming distance between frame types}
	\label{tab:0ACK}
\end{table}
\subsection{Using Team 4 physical layer}
\section{End-to-End Local Machine Testing }
%Renato

